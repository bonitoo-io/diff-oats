// This file is generated by [oats][0] and should not be edited by hand.
//
// [0]: https://github.com/influxdata/oats

export interface Me {
  /** the idpe id of the user */
  id: string
  /** the email associated with the user */
  email: string
  accountType: AccountType
  /** the billing provider for the account, nil if none */
  billingProvider: 'zuora' | 'aws' | 'gcm' | 'azure'
  /** the url of the current cluster */
  clusterHost: string
  /** whether the region associated with the account is a beta region */
  isRegionBeta: boolean
  /** the code associated with the region */
  regionCode: string
  /** the name of the region */
  regionName: string
  /** whether the user is an operator */
  isOperator: boolean
  /** role permission whether this operator is "read-only" | "read-write" */
  operatorRole?: 'read-only' | 'read-write'
  /** an ISO8601 timestamp that indicates when the account was created */
  accountCreatedAt: string
  /** an ISO8601 timestamp indicates if an account is part of the payg credit experiment, nil if not */
  paygCreditStartDate?: string
}

/**
 * type of the account
 */
export type AccountType = 'cancelled' | 'contract' | 'free' | 'pay_as_you_go'

export interface Error {
  /** code is the machine-readable error code. */
  readonly code:
    | 'internal error'
    | 'not found'
    | 'conflict'
    | 'invalid'
    | 'unprocessable entity'
    | 'empty value'
    | 'unavailable'
    | 'forbidden'
    | 'too many requests'
    | 'unauthorized'
    | 'method not allowed'
    | 'request too large'
    | 'unsupported media type'
  /** Human-readable message. */
  readonly message?: string
  /** Describes the logical code operation when the error occurred. Useful for debugging. */
  readonly op?: string
  /** Stack of errors that occurred during processing of the request. Useful for debugging. */
  readonly err?: string
}

export interface UserAccount {
  /** account id in quartz */
  id: number
  /** is this the currently active account in the session? */
  isActive: boolean
  /** is this the user's default account? */
  isDefault: boolean
  /** name of the account */
  name: string
}

export interface Account {
  /** account id in quartz */
  id: number
  /** name of the account */
  name: string
  /** the type of the account */
  type?: 'contract' | 'free' | 'pay_as_you_go'
  /** the billing provider of the account. null if a free account */
  billingProvider?: 'aws' | 'azure' | 'gcm' | 'zuora'
}

export type OrganizationSummaries = Array<{
  /** IDPE ID of the org */
  id: string
  /** name of the org */
  name: string
  /** is this the currently active organization in the session? */
  isActive: boolean
  /** is this the user's default organization in this account? */
  isDefault: boolean
}>

export interface OrganizationDefaultRequest {
  /** IDPE id of the organization */
  id: string
}

export type Clusters = Cluster[]

export interface Cluster {
  /** determines if the cluster is in beta */
  readonly isBeta?: string
  /** priority for sorting the cluster */
  readonly priority?: string
  /** determines if the provider is available */
  readonly isProviderAvailable?: string
  /** determines if the region is available */
  readonly isRegionAvailable?: string
  /** the id of the cloud provider */
  readonly providerId?: string
  /** the descriptive name of the cloud provider */
  readonly providerName?: string
  /** the id of the region */
  readonly regionId?: string
  /** the descriptive name of the region */
  readonly regionName?: string
}

export interface BillingInfo {
  /** account balance */
  balance: number
  paymentMethod?: PaymentMethod
  /** date of last update to account */
  balanceUpdatedAt: string
  contact: BillingContact
}

export interface PaymentMethod {
  /** name of credit card vendor */
  cardType: string
  /** masked credit card number */
  cardNumber: string
  /** month of expiration */
  expirationMonth: string
  /** year of expiration */
  expirationYear: string
  /** this the default payment method */
  defaultPaymentMethod?: boolean
}

export interface BillingContact {
  /** name of the company billed */
  companyName: string
  /** billing email */
  email: string
  /** first name of billing contact */
  firstName: string
  /** last name of billing contact */
  lastName: string
  /** country of billing contact */
  country: string
  /** street of billing contact */
  street1?: string
  /** additional street info */
  street2?: string
  /** city of billing contact */
  city: string
  /** subdivision */
  subdivision?: string
  /** postal code of billing contact */
  postalCode: string
}

export interface Identity {
  user: IdentityUser
  account: IdentityAccount
  org: IdentityOrganization
}

export interface IdentityUser {
  /** user's id in idpe */
  id: string
  /** user's email */
  email: string
  /** user's first name */
  firstName?: string
  /** user's last name */
  lastName?: string
  /** role permission whether this operator is "read-only" | "read-write" */
  operatorRole?: 'read-only' | 'read-write'
  /** number of accounts the user belongs to */
  accountCount: number
  /** number of orgs the user belongs to within their active account */
  orgCount: number
}

export interface IdentityAccount {
  /** account id in quartz */
  id: number
  /** name of the account */
  name: string
  type: AccountType
  /** an ISO8601 timestamp that indicates when the account was created */
  accountCreatedAt: string
  /** whether or not the account can be upgraded to payg */
  isUpgradeable?: boolean
  /** an ISO8601 timestamp indicating if an account is part of the payg credit experiment, nil if not */
  paygCreditStartDate?: string
}

export interface IdentityOrganization {
  /** idpe ID of the org */
  id: string
  /** name of the org */
  name: string
  /** the url of the current cluster */
  clusterHost: string
}

export interface Marketplace {
  /** full name of the marketplace */
  name: string
  /** marketplace acronyms */
  shortName: MarketplaceType
  /** link to marketplace */
  url: string
}

/**
 * marketplace acronym or name
 */
export type MarketplaceType = 'aws' | 'gcm' | 'azure'

export interface BillingDate {
  /** UTC datetime representing the start of the billing period for the account */
  dateTime: string
}

export type UsageVectors = UsageVector[]

export interface UsageVector {
  /** name of usage vector */
  name: string
  /** unit for usage vector */
  unit: string
  /** key in flux response */
  fluxKey: string
}

export interface BillingNotifySettings {
  /** opt in to threshold notifications */
  isNotify: boolean
  /** threshold that when passed will trigger a notification */
  balanceThreshold: number
  /** email to send notification */
  notifyEmail: string
}

export interface CreditCardParams {
  /** id of the page displayed */
  readonly id: string
  /** id of our account with the payment processor */
  readonly tenantId: string
  /** payment processor secret key */
  readonly key: string
  /** signature of the key or token */
  readonly signature: string
  /** api token of the payment processor */
  readonly token: string
  /** way payment form gets displayed */
  readonly style: string
  /** boolean string 'true' or 'false' which allows us to handle submits from our form */
  readonly submitEnabled: 'true' | 'false'
  /** uri of the embedded iframe */
  readonly url: string
}

export interface PaymentMethodPut {
  /** ref id from Zuora */
  readonly paymentMethodId?: string
}

export type Invoices = Invoice[]

export interface Invoice {
  /** id of the invoice */
  id: string
  /** status of the invoice */
  readonly status: string
  /** amount of invoice in dollars */
  readonly amount: number
  /** date of invoice */
  readonly targetDate: string
}

export interface OrganizationCreateRequest {
  /** name of the organization */
  orgName: string
  /** name of the cloud provider */
  provider: 'AWS' | 'GCP' | 'Azure'
  /** name of the region within the cloud provider */
  region: string
}

export type OrganizationWithToken = Organization & {
  /** Authentication token to manage the organization and its resources in IDPE */
  readonly token?: string
  /** Links to the IDPE resources for this organization */
  readonly links?: any
}

export interface Organization {
  /** IDPE Id of the org */
  id: string
  /** name of the org */
  name?: string
  /** the description of the organization */
  description?: string
  /** the date the organization was created */
  creationDate?: string
  /** the canonical code for the region where the organization is hosted */
  regionCode: string
  /** the name of the region where the organization is hosted */
  regionName: string
  /** provider of the org */
  provider?: string
  /** is the region of the organization in beta */
  isRegionBeta: boolean
  /** the url of the current cluster */
  clusterHost: string
}

export type Invites = Invite[]

export interface Invite {
  /** the quartz id of the invite */
  readonly id?: number
  email: string
  role: Role
  /** when the invite will expire */
  readonly expiresAt?: string
}

/**
 * Role of the User
 */
export type Role = 'owner' | 'member'

export interface OrgUser {
  /** the idpe id of the user */
  readonly id: string
  firstName: string
  lastName: string
  email: string
  role: Role
}

export type OrgUsers = OrgUser[]

export interface OrgLimits {
  /** The ID of the organization that the rates apply to. */
  readonly orgID: string
  rate: RateLimits
  bucket: BucketLimits
  task: TaskLimits
  dashboard: DashboardLimits
  check: CheckLimits
  notificationRule: NotificationRuleLimits
  notificationEndpoint: NotificationEndpointLimits
}

/**
 * Usage rate limits
 */
export interface RateLimits {
  /** KB of data query'd per second */
  readKBs?: RestrictedLimit | Limit
  /** KB of data written per second */
  writeKBs?: RestrictedLimit | Limit
  /** Max cardinality of data */
  cardinality?: RestrictedLimit | Limit
}

/**
 * Restrict access entirely
 */
export type RestrictedLimit = number

/**
 * Limit of at least 1
 */
export type Limit = number

/**
 * Bucket limits
 */
export interface BucketLimits {
  /** Number of buckets allowed */
  maxBuckets?: RestrictedLimit | Unlimited | Limit
  /** Retention duration limits in nanoseconds */
  maxRetentionDuration?: RestrictedLimit | Unlimited | Limit
}

/**
 * Unbounded limit
 */
export type Unlimited = number

/**
 * Task limits
 */
export interface TaskLimits {
  /** Number of tasks allowed */
  maxTasks?: RestrictedLimit | Unlimited | Limit
}

/**
 * Dashboard limits
 */
export interface DashboardLimits {
  /** Number of dashboards allowed */
  maxDashboards?: RestrictedLimit | Unlimited | Limit
}

/**
 * Check limits
 */
export interface CheckLimits {
  /** Number of checks allowed */
  maxChecks?: RestrictedLimit | Unlimited | Limit
}

/**
 * Notification rule limits
 */
export interface NotificationRuleLimits {
  /** Number of notifications allowed */
  maxNotifications?: RestrictedLimit | Unlimited | Limit
  /** Notification rules not allowed CSV */
  blockedNotificationRules?: string
}

/**
 * Notification endpoint limits
 */
export interface NotificationEndpointLimits {
  /** Notification endpoints not allowed CSV */
  blockedNotificationEndpoints?: string
}

export interface CheckoutRequest {
  /** id from submitting the zuora form */
  paymentMethodId?: string
  /** for billing address */
  street1?: string
  /** for billing address */
  street2?: string
  /** for billing address */
  city?: string
  /** for billing address */
  country?: string
  /** for billing address (state in US) */
  subdivision?: string
  /** for billing address */
  postalCode?: string
  /** the email for the notification */
  notifyEmail?: string
  /** threshold for notification */
  balanceThreshold?: number
  /** whether the user will be notified about their balance */
  isNotify?: boolean
  /** whether the user is a part of the payg credit */
  isPaygCreditActive?: boolean
}

export type OperatorAccounts = OperatorAccount[]

export interface OperatorAccount {
  /** account id in quartz */
  id: number
  /** account name */
  name: string
  type: AccountType
  /** Zuora ID associated with the account */
  zuoraAccountId?: string
  /** flag whether the account can be deleted or not */
  deletable?: boolean
  /** remaining balance on the account, nil if none */
  balance: number
  /** billing contact for the account */
  billingContact: BillingContact
  users: OperatorUsers
  /** which marketplace, nil if none */
  marketplaceSubscription: MarketplaceSubscription
}

export type OperatorUsers = OperatorUser[]

export interface OperatorUser {
  /** user's email */
  email?: string
  /** user's first name */
  firstName: string
  /** user's id in quartz */
  id: string
  /** user's id in idpe */
  idpeId: string
  /** user's last name */
  lastName: string
  /** whether or not the user is an operator */
  operator?: boolean
  /** the contact id of the user in salesforce */
  sfdcContactId?: string
}

export interface MarketplaceSubscription {
  marketplace: MarketplaceType
  /** status of the marketplace */
  status: 'pending' | 'subscribed' | 'unsubscribed' | 'failed'
  subscriberId: string
}

export type OperatorOrganizations = OperatorOrganization[]

export interface OperatorOrganization {
  /** idpe ID of the org */
  idpeId: string
  /** quartz ID of the org */
  id: number
  /** name of the org */
  name?: string
  /** region of the org */
  region: string
  /** provider of the org */
  provider: string
  /** date org was created */
  date: string
  account: RelatedAccount
}

/**
 * Subset of Account data related to the organization
 */
export interface RelatedAccount {
  /** account id in quartz */
  id: number
  type: AccountType
  /** remaining balance on the account, nil if none */
  balance: number
  /** billing contact for the account */
  billingContact?: BillingContact
  /** date of last update to account */
  updatedAt: string
}

export interface OperatorProvidersResponse {
  providers: OperatorProviders
  regions: {
    Azure?: OperatorRegions
    AWS?: OperatorRegions
    GCM?: OperatorRegions
  }
}

export type OperatorProviders = OperatorProvider[]

export interface OperatorProvider {
  /** name of the provider */
  provider: string
  /** title of the provider */
  title: string
  /** the availability of the provider */
  isAvailable: boolean
}

export type OperatorRegions = OperatorRegion[]

export interface OperatorRegion {
  /** the name of the region */
  region: string
  /** the title of the region */
  title: string
  /** the provider the region belong to */
  provider: string
  /** the order priority of the region */
  priority: number
  /** the availability of the provider */
  isAvailable: boolean
  /** determines if the region is in beta */
  isBeta: boolean
  /** determines if the region is a private region */
  isPrivate: boolean
}

export interface OperatorOrgLimits {
  /** The ID of the organization that these rates apply to. */
  readonly orgID: string
  rate: OperatorRateLimits
  bucket: BucketLimits
  task: TaskLimits
  dashboard: DashboardLimits
  check: CheckLimits
  notificationRule: NotificationRuleLimits
  notificationEndpoint: NotificationEndpointLimits
}

/**
 * Usage rate limits
 */
export interface OperatorRateLimits {
  /** Query Time limit in nanoseconds */
  queryTime?: RestrictedLimit | Limit
  /** KB of data query'd per second */
  readKBs?: RestrictedLimit | Limit
  /** KB of data written per second */
  writeKBs?: RestrictedLimit | Limit
  /** Max cardinality of data */
  cardinality?: RestrictedLimit | Limit
}

export interface UserPatchRequest {
  /** user's first name */
  firstName?: string
  /** user's last name */
  lastName?: string
}

export interface User {
  /** user's email */
  email?: string
  /** user's first name */
  firstName: string
  /** user's id in idpe */
  id: string
  /** user's last name */
  lastName: string
}

interface RequestOptions {
  signal?: AbortSignal
}

export type RequestHandler = (
  url: string,
  query: string,
  init: RequestInit
) => {url: string; query: string; init: RequestInit}
export type ResponseHandler = (
  status: number,
  headers: Headers,
  data: any
) => {status: number; headers: Headers; data: any}

const RequestContext = function (
  requestHandler: RequestHandler,
  responseHandler: ResponseHandler
) {
  this.requestHandler = requestHandler
  this.responseHandler = responseHandler
}

RequestContext.prototype.request = async function (
  method: string,
  url: string,
  params: any = {},
  options: RequestOptions = {}
): Promise<any> {
  const requestHeaders = new Headers(params.headers)
  const contentType = requestHeaders.get('Content-Type') || ''

  if (params.auth) {
    const credentials = btoa(`${params.auth.username}:${params.auth.password}`)

    requestHeaders.append('Authorization', `Basic ${credentials}`)
  }

  const body =
    params.data && contentType.includes('json')
      ? JSON.stringify(params.data)
      : params.data

  const query = params.query ? `?${new URLSearchParams(params.query)}` : ''

  const {
    url: middlewareUrl,
    query: middlewareQuery,
    init,
  } = this.requestHandler(url, query, {
    method,
    body,
    credentials: 'same-origin',
    signal: options.signal,
    headers: requestHeaders,
  })

  const response = await fetch(`${middlewareUrl}${middlewareQuery}`, init)

  const {status, headers} = response
  const responseContentType = headers.get('Content-Type') || ''

  let data

  if (responseContentType.includes('json')) {
    data = await response.json()
  } else if (responseContentType.includes('octet-stream')) {
    data = await response.blob()
  } else {
    data = await response.text()
  }

  return this.responseHandler(status, headers, data)
}

RequestContext.prototype.setRequestHandler = function (
  requestHandler: RequestHandler
) {
  this.requestHandler = requestHandler
}

RequestContext.prototype.setResponseHandler = function (
  responseHandler: ResponseHandler
) {
  this.responseHandler = responseHandler
}

const rc = new RequestContext(
  (url, query, init) => {
    return {url, query, init}
  },
  (status, headers, data) => {
    return {status, headers, data}
  }
)
const request = rc.request.bind(rc)
const setRequestHandler = rc.setRequestHandler.bind(rc)
const setResponseHandler = rc.setResponseHandler.bind(rc)

export {request, setRequestHandler, setResponseHandler}

export interface GetMeParams {}

type GetMeResult =
  | GetMeOKResult
  | GetMeUnauthorizedResult
  | GetMeNotFoundResult
  | GetMeDefaultResult

interface GetMeOKResult {
  status: 200
  headers: Headers
  data: Me
}

interface GetMeUnauthorizedResult {
  status: 401
  headers: Headers
  data: Error
}

interface GetMeNotFoundResult {
  status: 404
  headers: Headers
  data: Error
}

interface GetMeDefaultResult {
  status: 500
  headers: Headers
  data: Error
}

export const getMe = (
  params: GetMeParams,
  options: RequestOptions = {}
): Promise<GetMeResult> =>
  request('GET', '/api/v2/quartz/me', params, options) as Promise<GetMeResult>

export interface DeleteAccountParams {
  data?: any
}

type DeleteAccountResult =
  | DeleteAccountNoContentResult
  | DeleteAccountUnauthorizedResult
  | DeleteAccountMethodNotAllowedResult
  | DeleteAccountDefaultResult

interface DeleteAccountNoContentResult {
  status: 204
  headers: Headers
  data: any
}

interface DeleteAccountUnauthorizedResult {
  status: 401
  headers: Headers
  data: Error
}

interface DeleteAccountMethodNotAllowedResult {
  status: 405
  headers: Headers
  data: Error
}

interface DeleteAccountDefaultResult {
  status: 500
  headers: Headers
  data: Error
}

export const deleteAccount = (
  params: DeleteAccountParams,
  options: RequestOptions = {}
): Promise<DeleteAccountResult> =>
  request(
    'DELETE',
    '/api/v2/quartz/account',
    {...params, headers: {'Content-Type': 'application/json; charset=utf-8'}},
    options
  ) as Promise<DeleteAccountResult>

export interface GetAccountsParams {}

type GetAccountsResult =
  | GetAccountsOKResult
  | GetAccountsUnauthorizedResult
  | GetAccountsDefaultResult

interface GetAccountsOKResult {
  status: 200
  headers: Headers
  data: UserAccount[]
}

interface GetAccountsUnauthorizedResult {
  status: 401
  headers: Headers
  data: Error
}

interface GetAccountsDefaultResult {
  status: 500
  headers: Headers
  data: Error
}

export const getAccounts = (
  params: GetAccountsParams,
  options: RequestOptions = {}
): Promise<GetAccountsResult> =>
  request(
    'GET',
    '/api/v2/quartz/accounts',
    params,
    options
  ) as Promise<GetAccountsResult>

export interface GetAccountParams {
  accountId: string

  headers?: {
    'Zap-Trace-Span'?: string
  }
}

type GetAccountResult =
  | GetAccountOKResult
  | GetAccountUnauthorizedResult
  | GetAccountDefaultResult

interface GetAccountOKResult {
  status: 200
  headers: Headers
  data: Account
}

interface GetAccountUnauthorizedResult {
  status: 401
  headers: Headers
  data: Error
}

interface GetAccountDefaultResult {
  status: 500
  headers: Headers
  data: Error
}

export const getAccount = (
  params: GetAccountParams,
  options: RequestOptions = {}
): Promise<GetAccountResult> =>
  request(
    'GET',
    `/api/v2/quartz/accounts/${params.accountId}`,
    params,
    options
  ) as Promise<GetAccountResult>

export interface PatchAccountParams {
  accountId: string

  data: {
    /** name of the account */
    name: string
  }

  headers?: {
    'Zap-Trace-Span'?: string
  }
}

type PatchAccountResult =
  | PatchAccountOKResult
  | PatchAccountUnauthorizedResult
  | PatchAccountUnprocessableEntityResult
  | PatchAccountDefaultResult

interface PatchAccountOKResult {
  status: 200
  headers: Headers
  data: Account
}

interface PatchAccountUnauthorizedResult {
  status: 401
  headers: Headers
  data: Error
}

interface PatchAccountUnprocessableEntityResult {
  status: 422
  headers: Headers
  data: Error
}

interface PatchAccountDefaultResult {
  status: 500
  headers: Headers
  data: Error
}

export const patchAccount = (
  params: PatchAccountParams,
  options: RequestOptions = {}
): Promise<PatchAccountResult> =>
  request(
    'PATCH',
    `/api/v2/quartz/accounts/${params.accountId}`,
    {
      ...params,
      headers: {...params.headers, 'Content-Type': 'application/json'},
    },
    options
  ) as Promise<PatchAccountResult>

export interface GetAccountsOrgsParams {
  accountId: string

  headers?: {
    'Zap-Trace-Span'?: string
  }
}

type GetAccountsOrgsResult =
  | GetAccountsOrgsOKResult
  | GetAccountsOrgsUnauthorizedResult
  | GetAccountsOrgsDefaultResult

interface GetAccountsOrgsOKResult {
  status: 200
  headers: Headers
  data: OrganizationSummaries
}

interface GetAccountsOrgsUnauthorizedResult {
  status: 401
  headers: Headers
  data: Error
}

interface GetAccountsOrgsDefaultResult {
  status: 500
  headers: Headers
  data: Error
}

export const getAccountsOrgs = (
  params: GetAccountsOrgsParams,
  options: RequestOptions = {}
): Promise<GetAccountsOrgsResult> =>
  request(
    'GET',
    `/api/v2/quartz/accounts/${params.accountId}/orgs`,
    params,
    options
  ) as Promise<GetAccountsOrgsResult>

export interface PutAccountsOrgsDefaultParams {
  accountId: string

  data: OrganizationDefaultRequest
}

type PutAccountsOrgsDefaultResult =
  | PutAccountsOrgsDefaultNoContentResult
  | PutAccountsOrgsDefaultNotFoundResult
  | PutAccountsOrgsDefaultUnprocessableEntityResult
  | PutAccountsOrgsDefaultDefaultResult

interface PutAccountsOrgsDefaultNoContentResult {
  status: 204
  headers: Headers
  data: any
}

interface PutAccountsOrgsDefaultNotFoundResult {
  status: 404
  headers: Headers
  data: Error
}

interface PutAccountsOrgsDefaultUnprocessableEntityResult {
  status: 422
  headers: Headers
  data: Error
}

interface PutAccountsOrgsDefaultDefaultResult {
  status: 500
  headers: Headers
  data: Error
}

export const putAccountsOrgsDefault = (
  params: PutAccountsOrgsDefaultParams,
  options: RequestOptions = {}
): Promise<PutAccountsOrgsDefaultResult> =>
  request(
    'PUT',
    `/api/v2/quartz/accounts/${params.accountId}/orgs/default`,
    {...params, headers: {'Content-Type': 'application/json'}},
    options
  ) as Promise<PutAccountsOrgsDefaultResult>

export interface PutAccountsDefaultParams {
  data: {
    /** account id in quartz */
    id: number
  }
}

type PutAccountsDefaultResult =
  | PutAccountsDefaultNoContentResult
  | PutAccountsDefaultDefaultResult

interface PutAccountsDefaultNoContentResult {
  status: 204
  headers: Headers
  data: any
}

interface PutAccountsDefaultDefaultResult {
  status: 500
  headers: Headers
  data: Error
}

export const putAccountsDefault = (
  params: PutAccountsDefaultParams,
  options: RequestOptions = {}
): Promise<PutAccountsDefaultResult> =>
  request(
    'PUT',
    '/api/v2/quartz/accounts/default',
    {...params, headers: {'Content-Type': 'application/json'}},
    options
  ) as Promise<PutAccountsDefaultResult>

export interface GetClustersParams {}

type GetClustersResult =
  | GetClustersOKResult
  | GetClustersUnauthorizedResult
  | GetClustersDefaultResult

interface GetClustersOKResult {
  status: 200
  headers: Headers
  data: Clusters
}

interface GetClustersUnauthorizedResult {
  status: 401
  headers: Headers
  data: Error
}

interface GetClustersDefaultResult {
  status: 500
  headers: Headers
  data: Error
}

export const getClusters = (
  params: GetClustersParams,
  options: RequestOptions = {}
): Promise<GetClustersResult> =>
  request(
    'GET',
    '/api/v2/quartz/clusters',
    params,
    options
  ) as Promise<GetClustersResult>

export interface GetBillingParams {}

type GetBillingResult = GetBillingOKResult | GetBillingDefaultResult

interface GetBillingOKResult {
  status: 200
  headers: Headers
  data: BillingInfo
}

interface GetBillingDefaultResult {
  status: 500
  headers: Headers
  data: Error
}

export const getBilling = (
  params: GetBillingParams,
  options: RequestOptions = {}
): Promise<GetBillingResult> =>
  request(
    'GET',
    '/api/v2/quartz/billing',
    params,
    options
  ) as Promise<GetBillingResult>

export interface GetIdentityParams {}

type GetIdentityResult =
  | GetIdentityOKResult
  | GetIdentityUnauthorizedResult
  | GetIdentityDefaultResult

interface GetIdentityOKResult {
  status: 200
  headers: Headers
  data: Identity
}

interface GetIdentityUnauthorizedResult {
  status: 401
  headers: Headers
  data: Error
}

interface GetIdentityDefaultResult {
  status: 500
  headers: Headers
  data: Error
}

export const getIdentity = (
  params: GetIdentityParams,
  options: RequestOptions = {}
): Promise<GetIdentityResult> =>
  request(
    'GET',
    '/api/v2/quartz/identity',
    params,
    options
  ) as Promise<GetIdentityResult>

export interface GetMarketplaceParams {}

type GetMarketplaceResult =
  | GetMarketplaceOKResult
  | GetMarketplaceUnauthorizedResult
  | GetMarketplaceNotFoundResult
  | GetMarketplaceDefaultResult

interface GetMarketplaceOKResult {
  status: 200
  headers: Headers
  data: Marketplace
}

interface GetMarketplaceUnauthorizedResult {
  status: 401
  headers: Headers
  data: Error
}

interface GetMarketplaceNotFoundResult {
  status: 404
  headers: Headers
  data: Error
}

interface GetMarketplaceDefaultResult {
  status: 500
  headers: Headers
  data: Error
}

export const getMarketplace = (
  params: GetMarketplaceParams,
  options: RequestOptions = {}
): Promise<GetMarketplaceResult> =>
  request(
    'GET',
    '/api/v2/quartz/marketplace',
    params,
    options
  ) as Promise<GetMarketplaceResult>

export interface GetBillingStartDateParams {}

type GetBillingStartDateResult =
  | GetBillingStartDateOKResult
  | GetBillingStartDateDefaultResult

interface GetBillingStartDateOKResult {
  status: 200
  headers: Headers
  data: BillingDate
}

interface GetBillingStartDateDefaultResult {
  status: 500
  headers: Headers
  data: Error
}

export const getBillingStartDate = (
  params: GetBillingStartDateParams,
  options: RequestOptions = {}
): Promise<GetBillingStartDateResult> =>
  request(
    'GET',
    '/api/v2/quartz/billing/start_date',
    params,
    options
  ) as Promise<GetBillingStartDateResult>

export interface GetUsageVectorsParams {}

type GetUsageVectorsResult =
  | GetUsageVectorsOKResult
  | GetUsageVectorsUnauthorizedResult
  | GetUsageVectorsNotFoundResult
  | GetUsageVectorsDefaultResult

interface GetUsageVectorsOKResult {
  status: 200
  headers: Headers
  data: UsageVectors
}

interface GetUsageVectorsUnauthorizedResult {
  status: 401
  headers: Headers
  data: Error
}

interface GetUsageVectorsNotFoundResult {
  status: 404
  headers: Headers
  data: Error
}

interface GetUsageVectorsDefaultResult {
  status: 500
  headers: Headers
  data: Error
}

export const getUsageVectors = (
  params: GetUsageVectorsParams,
  options: RequestOptions = {}
): Promise<GetUsageVectorsResult> =>
  request(
    'GET',
    '/api/v2/quartz/usage/vectors',
    params,
    options
  ) as Promise<GetUsageVectorsResult>

export interface GetUsageParams {
  vector_name: any

  query?: {
    range?: any
  }
}

type GetUsageResult =
  | GetUsageOKResult
  | GetUsageBadRequestResult
  | GetUsageUnauthorizedResult
  | GetUsageNotFoundResult
  | GetUsageDefaultResult

interface GetUsageOKResult {
  status: 200
  headers: Headers
  data: string
}

interface GetUsageBadRequestResult {
  status: 400
  headers: Headers
  data: Error
}

interface GetUsageUnauthorizedResult {
  status: 401
  headers: Headers
  data: Error
}

interface GetUsageNotFoundResult {
  status: 404
  headers: Headers
  data: Error
}

interface GetUsageDefaultResult {
  status: 500
  headers: Headers
  data: Error
}

export const getUsage = (
  params: GetUsageParams,
  options: RequestOptions = {}
): Promise<GetUsageResult> =>
  request(
    'GET',
    `/api/v2/quartz/usage/${params.vector_name}`,
    params,
    options
  ) as Promise<GetUsageResult>

export interface GetUsageBillingStatsParams {}

type GetUsageBillingStatsResult =
  | GetUsageBillingStatsOKResult
  | GetUsageBillingStatsUnauthorizedResult
  | GetUsageBillingStatsDefaultResult

interface GetUsageBillingStatsOKResult {
  status: 200
  headers: Headers
  data: string
}

interface GetUsageBillingStatsUnauthorizedResult {
  status: 401
  headers: Headers
  data: Error
}

interface GetUsageBillingStatsDefaultResult {
  status: 500
  headers: Headers
  data: Error
}

export const getUsageBillingStats = (
  params: GetUsageBillingStatsParams,
  options: RequestOptions = {}
): Promise<GetUsageBillingStatsResult> =>
  request(
    'GET',
    '/api/v2/quartz/usage/billing_stats',
    params,
    options
  ) as Promise<GetUsageBillingStatsResult>

export interface GetUsageRateLimitsParams {
  query?: {
    range?: any
  }
}

type GetUsageRateLimitsResult =
  | GetUsageRateLimitsOKResult
  | GetUsageRateLimitsBadRequestResult
  | GetUsageRateLimitsUnauthorizedResult
  | GetUsageRateLimitsNotFoundResult
  | GetUsageRateLimitsDefaultResult

interface GetUsageRateLimitsOKResult {
  status: 200
  headers: Headers
  data: string
}

interface GetUsageRateLimitsBadRequestResult {
  status: 400
  headers: Headers
  data: Error
}

interface GetUsageRateLimitsUnauthorizedResult {
  status: 401
  headers: Headers
  data: Error
}

interface GetUsageRateLimitsNotFoundResult {
  status: 404
  headers: Headers
  data: Error
}

interface GetUsageRateLimitsDefaultResult {
  status: 500
  headers: Headers
  data: Error
}

export const getUsageRateLimits = (
  params: GetUsageRateLimitsParams,
  options: RequestOptions = {}
): Promise<GetUsageRateLimitsResult> =>
  request(
    'GET',
    '/api/v2/quartz/usage/rate_limits',
    params,
    options
  ) as Promise<GetUsageRateLimitsResult>

export interface GetSettingsNotificationsParams {}

type GetSettingsNotificationsResult =
  | GetSettingsNotificationsOKResult
  | GetSettingsNotificationsUnauthorizedResult
  | GetSettingsNotificationsNotFoundResult
  | GetSettingsNotificationsNotAcceptableResult
  | GetSettingsNotificationsDefaultResult

interface GetSettingsNotificationsOKResult {
  status: 200
  headers: Headers
  data: BillingNotifySettings
}

interface GetSettingsNotificationsUnauthorizedResult {
  status: 401
  headers: Headers
  data: Error
}

interface GetSettingsNotificationsNotFoundResult {
  status: 404
  headers: Headers
  data: Error
}

interface GetSettingsNotificationsNotAcceptableResult {
  status: 406
  headers: Headers
  data: Error
}

interface GetSettingsNotificationsDefaultResult {
  status: 500
  headers: Headers
  data: Error
}

export const getSettingsNotifications = (
  params: GetSettingsNotificationsParams,
  options: RequestOptions = {}
): Promise<GetSettingsNotificationsResult> =>
  request(
    'GET',
    '/api/v2/quartz/settings/notifications',
    params,
    options
  ) as Promise<GetSettingsNotificationsResult>

export interface PutSettingsNotificationsParams {
  data: BillingNotifySettings
}

type PutSettingsNotificationsResult =
  | PutSettingsNotificationsOKResult
  | PutSettingsNotificationsBadRequestResult
  | PutSettingsNotificationsUnauthorizedResult
  | PutSettingsNotificationsDefaultResult

interface PutSettingsNotificationsOKResult {
  status: 200
  headers: Headers
  data: BillingNotifySettings
}

interface PutSettingsNotificationsBadRequestResult {
  status: 400
  headers: Headers
  data: Error
}

interface PutSettingsNotificationsUnauthorizedResult {
  status: 401
  headers: Headers
  data: Error
}

interface PutSettingsNotificationsDefaultResult {
  status: 500
  headers: Headers
  data: Error
}

export const putSettingsNotifications = (
  params: PutSettingsNotificationsParams,
  options: RequestOptions = {}
): Promise<PutSettingsNotificationsResult> =>
  request(
    'PUT',
    '/api/v2/quartz/settings/notifications',
    {...params, headers: {'Content-Type': 'application/json'}},
    options
  ) as Promise<PutSettingsNotificationsResult>

export interface PutBillingContactParams {
  data: BillingContact
}

type PutBillingContactResult =
  | PutBillingContactOKResult
  | PutBillingContactDefaultResult

interface PutBillingContactOKResult {
  status: 200
  headers: Headers
  data: BillingContact
}

interface PutBillingContactDefaultResult {
  status: 500
  headers: Headers
  data: Error
}

export const putBillingContact = (
  params: PutBillingContactParams,
  options: RequestOptions = {}
): Promise<PutBillingContactResult> =>
  request(
    'PUT',
    '/api/v2/quartz/billing/contact',
    {...params, headers: {'Content-Type': 'application/json'}},
    options
  ) as Promise<PutBillingContactResult>

export interface GetPaymentFormParams {
  form: any
}

type GetPaymentFormResult =
  | GetPaymentFormOKResult
  | GetPaymentFormBadRequestResult
  | GetPaymentFormUnauthorizedResult
  | GetPaymentFormNotFoundResult
  | GetPaymentFormNotAcceptableResult
  | GetPaymentFormDefaultResult

interface GetPaymentFormOKResult {
  status: 200
  headers: Headers
  data: CreditCardParams
}

interface GetPaymentFormBadRequestResult {
  status: 400
  headers: Headers
  data: Error
}

interface GetPaymentFormUnauthorizedResult {
  status: 401
  headers: Headers
  data: Error
}

interface GetPaymentFormNotFoundResult {
  status: 404
  headers: Headers
  data: Error
}

interface GetPaymentFormNotAcceptableResult {
  status: 406
  headers: Headers
  data: Error
}

interface GetPaymentFormDefaultResult {
  status: 500
  headers: Headers
  data: Error
}

export const getPaymentForm = (
  params: GetPaymentFormParams,
  options: RequestOptions = {}
): Promise<GetPaymentFormResult> =>
  request(
    'GET',
    `/api/v2/quartz/payment_form/${params.form}`,
    params,
    options
  ) as Promise<GetPaymentFormResult>

export interface PutBillingPaymentMethodParams {
  data: PaymentMethodPut
}

type PutBillingPaymentMethodResult =
  | PutBillingPaymentMethodOKResult
  | PutBillingPaymentMethodDefaultResult

interface PutBillingPaymentMethodOKResult {
  status: 200
  headers: Headers
  data: PaymentMethod
}

interface PutBillingPaymentMethodDefaultResult {
  status: 500
  headers: Headers
  data: Error
}

export const putBillingPaymentMethod = (
  params: PutBillingPaymentMethodParams,
  options: RequestOptions = {}
): Promise<PutBillingPaymentMethodResult> =>
  request(
    'PUT',
    '/api/v2/quartz/billing/payment_method',
    {...params, headers: {'Content-Type': 'application/json'}},
    options
  ) as Promise<PutBillingPaymentMethodResult>

export interface GetBillingInvoicesParams {}

type GetBillingInvoicesResult =
  | GetBillingInvoicesOKResult
  | GetBillingInvoicesUnauthorizedResult
  | GetBillingInvoicesDefaultResult

interface GetBillingInvoicesOKResult {
  status: 200
  headers: Headers
  data: Invoices
}

interface GetBillingInvoicesUnauthorizedResult {
  status: 401
  headers: Headers
  data: Error
}

interface GetBillingInvoicesDefaultResult {
  status: 500
  headers: Headers
  data: Error
}

export const getBillingInvoices = (
  params: GetBillingInvoicesParams,
  options: RequestOptions = {}
): Promise<GetBillingInvoicesResult> =>
  request(
    'GET',
    '/api/v2/quartz/billing/invoices',
    params,
    options
  ) as Promise<GetBillingInvoicesResult>

export interface GetBillingInvoiceParams {
  invoiceId: string

  headers?: {
    'Zap-Trace-Span'?: string
  }
}

type GetBillingInvoiceResult =
  | GetBillingInvoiceOKResult
  | GetBillingInvoiceUnauthorizedResult
  | GetBillingInvoiceNotFoundResult
  | GetBillingInvoiceDefaultResult

interface GetBillingInvoiceOKResult {
  status: 200
  headers: Headers
  data: string
}

interface GetBillingInvoiceUnauthorizedResult {
  status: 401
  headers: Headers
  data: Error
}

interface GetBillingInvoiceNotFoundResult {
  status: 404
  headers: Headers
  data: Error
}

interface GetBillingInvoiceDefaultResult {
  status: 500
  headers: Headers
  data: Error
}

export const getBillingInvoice = (
  params: GetBillingInvoiceParams,
  options: RequestOptions = {}
): Promise<GetBillingInvoiceResult> =>
  request(
    'GET',
    `/api/v2/quartz/billing/invoices/${params.invoiceId}`,
    params,
    options
  ) as Promise<GetBillingInvoiceResult>

export interface PostOrgParams {
  data: OrganizationCreateRequest
}

type PostOrgResult =
  | PostOrgCreatedResult
  | PostOrgUnauthorizedResult
  | PostOrgConflictResult
  | PostOrgUnprocessableEntityResult
  | PostOrgDefaultResult

interface PostOrgCreatedResult {
  status: 201
  headers: Headers
  data: OrganizationWithToken
}

interface PostOrgUnauthorizedResult {
  status: 401
  headers: Headers
  data: Error
}

interface PostOrgConflictResult {
  status: 409
  headers: Headers
  data: Error
}

interface PostOrgUnprocessableEntityResult {
  status: 422
  headers: Headers
  data: Error
}

interface PostOrgDefaultResult {
  status: 500
  headers: Headers
  data: Error
}

export const postOrg = (
  params: PostOrgParams,
  options: RequestOptions = {}
): Promise<PostOrgResult> =>
  request(
    'POST',
    '/api/v2/quartz/orgs',
    {...params, headers: {'Content-Type': 'application/json'}},
    options
  ) as Promise<PostOrgResult>

export interface GetOrgParams {
  orgId: string
}

type GetOrgResult =
  | GetOrgOKResult
  | GetOrgUnauthorizedResult
  | GetOrgDefaultResult

interface GetOrgOKResult {
  status: 200
  headers: Headers
  data: Organization
}

interface GetOrgUnauthorizedResult {
  status: 401
  headers: Headers
  data: Error
}

interface GetOrgDefaultResult {
  status: 500
  headers: Headers
  data: Error
}

export const getOrg = (
  params: GetOrgParams,
  options: RequestOptions = {}
): Promise<GetOrgResult> =>
  request(
    'GET',
    `/api/v2/quartz/orgs/${params.orgId}`,
    params,
    options
  ) as Promise<GetOrgResult>

export interface PatchOrgParams {
  orgId: string

  data: {
    /** The name of the organization. */
    name?: string
    /** The description of the organization. */
    description?: string
  }
}

type PatchOrgResult =
  | PatchOrgOKResult
  | PatchOrgUnauthorizedResult
  | PatchOrgUnprocessableEntityResult
  | PatchOrgDefaultResult

interface PatchOrgOKResult {
  status: 200
  headers: Headers
  data: Organization
}

interface PatchOrgUnauthorizedResult {
  status: 401
  headers: Headers
  data: Error
}

interface PatchOrgUnprocessableEntityResult {
  status: 422
  headers: Headers
  data: Error
}

interface PatchOrgDefaultResult {
  status: 500
  headers: Headers
  data: Error
}

export const patchOrg = (
  params: PatchOrgParams,
  options: RequestOptions = {}
): Promise<PatchOrgResult> =>
  request(
    'PATCH',
    `/api/v2/quartz/orgs/${params.orgId}`,
    {...params, headers: {'Content-Type': 'application/json'}},
    options
  ) as Promise<PatchOrgResult>

export interface GetOrgsInvitesParams {
  orgId: string

  headers?: {
    'Zap-Trace-Span'?: string
  }
}

type GetOrgsInvitesResult =
  | GetOrgsInvitesOKResult
  | GetOrgsInvitesUnauthorizedResult
  | GetOrgsInvitesNotFoundResult
  | GetOrgsInvitesDefaultResult

interface GetOrgsInvitesOKResult {
  status: 200
  headers: Headers
  data: Invites
}

interface GetOrgsInvitesUnauthorizedResult {
  status: 401
  headers: Headers
  data: Error
}

interface GetOrgsInvitesNotFoundResult {
  status: 404
  headers: Headers
  data: Error
}

interface GetOrgsInvitesDefaultResult {
  status: 500
  headers: Headers
  data: Error
}

export const getOrgsInvites = (
  params: GetOrgsInvitesParams,
  options: RequestOptions = {}
): Promise<GetOrgsInvitesResult> =>
  request(
    'GET',
    `/api/v2/quartz/orgs/${params.orgId}/invites`,
    params,
    options
  ) as Promise<GetOrgsInvitesResult>

export interface PostOrgsInviteParams {
  orgId: string

  data: Invite

  headers?: {
    'Zap-Trace-Span'?: string
  }
}

type PostOrgsInviteResult =
  | PostOrgsInviteOKResult
  | PostOrgsInviteCreatedResult
  | PostOrgsInviteUnauthorizedResult
  | PostOrgsInviteNotFoundResult
  | PostOrgsInviteConflictResult
  | PostOrgsInviteUnprocessableEntityResult
  | PostOrgsInviteTooManyRequestsResult
  | PostOrgsInviteDefaultResult

interface PostOrgsInviteOKResult {
  status: 200
  headers: Headers
  data: OrgUser
}

interface PostOrgsInviteCreatedResult {
  status: 201
  headers: Headers
  data: Invite
}

interface PostOrgsInviteUnauthorizedResult {
  status: 401
  headers: Headers
  data: Error
}

interface PostOrgsInviteNotFoundResult {
  status: 404
  headers: Headers
  data: Error
}

interface PostOrgsInviteConflictResult {
  status: 409
  headers: Headers
  data: Error
}

interface PostOrgsInviteUnprocessableEntityResult {
  status: 422
  headers: Headers
  data: Error
}

interface PostOrgsInviteTooManyRequestsResult {
  status: 429
  headers: Headers
  data: Error
}

interface PostOrgsInviteDefaultResult {
  status: 500
  headers: Headers
  data: Error
}

export const postOrgsInvite = (
  params: PostOrgsInviteParams,
  options: RequestOptions = {}
): Promise<PostOrgsInviteResult> =>
  request(
    'POST',
    `/api/v2/quartz/orgs/${params.orgId}/invites`,
    {
      ...params,
      headers: {...params.headers, 'Content-Type': 'application/json'},
    },
    options
  ) as Promise<PostOrgsInviteResult>

export interface DeleteOrgsInviteParams {
  inviteId: number
  orgId: string

  data?: any

  headers?: {
    'Zap-Trace-Span'?: string
  }
}

type DeleteOrgsInviteResult =
  | DeleteOrgsInviteNoContentResult
  | DeleteOrgsInviteDefaultResult

interface DeleteOrgsInviteNoContentResult {
  status: 204
  headers: Headers
  data: any
}

interface DeleteOrgsInviteDefaultResult {
  status: 500
  headers: Headers
  data: Error
}

export const deleteOrgsInvite = (
  params: DeleteOrgsInviteParams,
  options: RequestOptions = {}
): Promise<DeleteOrgsInviteResult> =>
  request(
    'DELETE',
    `/api/v2/quartz/orgs/${params.orgId}/invites/${params.inviteId}`,
    {
      ...params,
      headers: {
        ...params.headers,
        'Content-Type': 'application/json; charset=utf-8',
      },
    },
    options
  ) as Promise<DeleteOrgsInviteResult>

export interface PostOrgsInvitesResendParams {
  inviteId: number
  orgId: string

  data?: any

  headers?: {
    'Zap-Trace-Span'?: string
  }
}

type PostOrgsInvitesResendResult =
  | PostOrgsInvitesResendOKResult
  | PostOrgsInvitesResendUnauthorizedResult
  | PostOrgsInvitesResendNotFoundResult
  | PostOrgsInvitesResendDefaultResult

interface PostOrgsInvitesResendOKResult {
  status: 200
  headers: Headers
  data: Invite
}

interface PostOrgsInvitesResendUnauthorizedResult {
  status: 401
  headers: Headers
  data: Error
}

interface PostOrgsInvitesResendNotFoundResult {
  status: 404
  headers: Headers
  data: Error
}

interface PostOrgsInvitesResendDefaultResult {
  status: 500
  headers: Headers
  data: Error
}

export const postOrgsInvitesResend = (
  params: PostOrgsInvitesResendParams,
  options: RequestOptions = {}
): Promise<PostOrgsInvitesResendResult> =>
  request(
    'POST',
    `/api/v2/quartz/orgs/${params.orgId}/invites/${params.inviteId}/resend`,
    {
      ...params,
      headers: {
        ...params.headers,
        'Content-Type': 'application/json; charset=utf-8',
      },
    },
    options
  ) as Promise<PostOrgsInvitesResendResult>

export interface GetOrgsUsersParams {
  orgId: string

  headers?: {
    'Zap-Trace-Span'?: string
  }
}

type GetOrgsUsersResult =
  | GetOrgsUsersOKResult
  | GetOrgsUsersUnauthorizedResult
  | GetOrgsUsersNotFoundResult
  | GetOrgsUsersDefaultResult

interface GetOrgsUsersOKResult {
  status: 200
  headers: Headers
  data: OrgUsers
}

interface GetOrgsUsersUnauthorizedResult {
  status: 401
  headers: Headers
  data: Error
}

interface GetOrgsUsersNotFoundResult {
  status: 404
  headers: Headers
  data: Error
}

interface GetOrgsUsersDefaultResult {
  status: 500
  headers: Headers
  data: Error
}

export const getOrgsUsers = (
  params: GetOrgsUsersParams,
  options: RequestOptions = {}
): Promise<GetOrgsUsersResult> =>
  request(
    'GET',
    `/api/v2/quartz/orgs/${params.orgId}/users`,
    params,
    options
  ) as Promise<GetOrgsUsersResult>

export interface DeleteOrgsUserParams {
  userId: string
  orgId: string

  data?: any

  headers?: {
    'Zap-Trace-Span'?: string
  }
}

type DeleteOrgsUserResult =
  | DeleteOrgsUserNoContentResult
  | DeleteOrgsUserBadRequestResult
  | DeleteOrgsUserUnauthorizedResult
  | DeleteOrgsUserNotFoundResult
  | DeleteOrgsUserDefaultResult

interface DeleteOrgsUserNoContentResult {
  status: 204
  headers: Headers
  data: any
}

interface DeleteOrgsUserBadRequestResult {
  status: 400
  headers: Headers
  data: Error
}

interface DeleteOrgsUserUnauthorizedResult {
  status: 401
  headers: Headers
  data: Error
}

interface DeleteOrgsUserNotFoundResult {
  status: 404
  headers: Headers
  data: Error
}

interface DeleteOrgsUserDefaultResult {
  status: 500
  headers: Headers
  data: Error
}

export const deleteOrgsUser = (
  params: DeleteOrgsUserParams,
  options: RequestOptions = {}
): Promise<DeleteOrgsUserResult> =>
  request(
    'DELETE',
    `/api/v2/quartz/orgs/${params.orgId}/users/${params.userId}`,
    {
      ...params,
      headers: {
        ...params.headers,
        'Content-Type': 'application/json; charset=utf-8',
      },
    },
    options
  ) as Promise<DeleteOrgsUserResult>

export interface GetOrgsLimitsParams {
  orgId: string
}

type GetOrgsLimitsResult = GetOrgsLimitsOKResult | GetOrgsLimitsDefaultResult

interface GetOrgsLimitsOKResult {
  status: 200
  headers: Headers
  data: OrgLimits
}

interface GetOrgsLimitsDefaultResult {
  status: 500
  headers: Headers
  data: Error
}

export const getOrgsLimits = (
  params: GetOrgsLimitsParams,
  options: RequestOptions = {}
): Promise<GetOrgsLimitsResult> =>
  request(
    'GET',
    `/api/v2/quartz/orgs/${params.orgId}/limits`,
    params,
    options
  ) as Promise<GetOrgsLimitsResult>

export interface PutOrgsLimitsParams {
  orgId: string

  data?: any
}

type PutOrgsLimitsResult = PutOrgsLimitsOKResult | PutOrgsLimitsDefaultResult

interface PutOrgsLimitsOKResult {
  status: 200
  headers: Headers
  data: OrgLimits
}

interface PutOrgsLimitsDefaultResult {
  status: 500
  headers: Headers
  data: Error
}

export const putOrgsLimits = (
  params: PutOrgsLimitsParams,
  options: RequestOptions = {}
): Promise<PutOrgsLimitsResult> =>
  request(
    'PUT',
    `/api/v2/quartz/orgs/${params.orgId}/limits`,
    {...params, headers: {'Content-Type': 'application/json; charset=utf-8'}},
    options
  ) as Promise<PutOrgsLimitsResult>

export interface PostCheckoutParams {
  data: CheckoutRequest
}

type PostCheckoutResult =
  | PostCheckoutCreatedResult
  | PostCheckoutBadRequestResult
  | PostCheckoutUnauthorizedResult
  | PostCheckoutNotFoundResult
  | PostCheckoutDefaultResult

interface PostCheckoutCreatedResult {
  status: 201
  headers: Headers
  data: any
}

interface PostCheckoutBadRequestResult {
  status: 400
  headers: Headers
  data: Error
}

interface PostCheckoutUnauthorizedResult {
  status: 401
  headers: Headers
  data: Error
}

interface PostCheckoutNotFoundResult {
  status: 404
  headers: Headers
  data: Error
}

interface PostCheckoutDefaultResult {
  status: 500
  headers: Headers
  data: Error
}

export const postCheckout = (
  params: PostCheckoutParams,
  options: RequestOptions = {}
): Promise<PostCheckoutResult> =>
  request(
    'POST',
    '/api/v2/quartz/checkout',
    {...params, headers: {'Content-Type': 'application/json'}},
    options
  ) as Promise<PostCheckoutResult>

export interface PostCancelParams {
  data?: any
}

type PostCancelResult = PostCancelNoContentResult | PostCancelDefaultResult

interface PostCancelNoContentResult {
  status: 204
  headers: Headers
  data: any
}

interface PostCancelDefaultResult {
  status: 500
  headers: Headers
  data: Error
}

export const postCancel = (
  params: PostCancelParams,
  options: RequestOptions = {}
): Promise<PostCancelResult> =>
  request(
    'POST',
    '/api/v2/quartz/cancel',
    {...params, headers: {'Content-Type': 'application/json; charset=utf-8'}},
    options
  ) as Promise<PostCancelResult>

export interface GetOperatorAccountsParams {
  query?: {
    query?: string
    accountTypes?: any
  }

  headers?: {
    'Zap-Trace-Span'?: string
  }
}

type GetOperatorAccountsResult =
  | GetOperatorAccountsOKResult
  | GetOperatorAccountsUnauthorizedResult
  | GetOperatorAccountsDefaultResult

interface GetOperatorAccountsOKResult {
  status: 200
  headers: Headers
  data: OperatorAccounts
}

interface GetOperatorAccountsUnauthorizedResult {
  status: 401
  headers: Headers
  data: Error
}

interface GetOperatorAccountsDefaultResult {
  status: 500
  headers: Headers
  data: Error
}

export const getOperatorAccounts = (
  params: GetOperatorAccountsParams,
  options: RequestOptions = {}
): Promise<GetOperatorAccountsResult> =>
  request(
    'GET',
    '/api/v2/quartz/operator/accounts',
    params,
    options
  ) as Promise<GetOperatorAccountsResult>

export interface GetOperatorAccountParams {
  accountId: string

  headers?: {
    'Zap-Trace-Span'?: string
  }
}

type GetOperatorAccountResult =
  | GetOperatorAccountOKResult
  | GetOperatorAccountUnauthorizedResult
  | GetOperatorAccountNotFoundResult
  | GetOperatorAccountDefaultResult

interface GetOperatorAccountOKResult {
  status: 200
  headers: Headers
  data: OperatorAccount & {
    /** organizations in the account */
    organizations?: OperatorOrganizations
  } & any
}

interface GetOperatorAccountUnauthorizedResult {
  status: 401
  headers: Headers
  data: Error
}

interface GetOperatorAccountNotFoundResult {
  status: 404
  headers: Headers
  data: Error
}

interface GetOperatorAccountDefaultResult {
  status: 500
  headers: Headers
  data: Error
}

export const getOperatorAccount = (
  params: GetOperatorAccountParams,
  options: RequestOptions = {}
): Promise<GetOperatorAccountResult> =>
  request(
    'GET',
    `/api/v2/quartz/operator/accounts/${params.accountId}`,
    params,
    options
  ) as Promise<GetOperatorAccountResult>

export interface DeleteOperatorAccountParams {
  accountId: string

  data?: any

  headers?: {
    'Zap-Trace-Span'?: string
  }
}

type DeleteOperatorAccountResult =
  | DeleteOperatorAccountNoContentResult
  | DeleteOperatorAccountBadRequestResult
  | DeleteOperatorAccountUnauthorizedResult
  | DeleteOperatorAccountDefaultResult

interface DeleteOperatorAccountNoContentResult {
  status: 204
  headers: Headers
  data: any
}

interface DeleteOperatorAccountBadRequestResult {
  status: 400
  headers: Headers
  data: Error
}

interface DeleteOperatorAccountUnauthorizedResult {
  status: 401
  headers: Headers
  data: Error
}

interface DeleteOperatorAccountDefaultResult {
  status: 500
  headers: Headers
  data: Error
}

export const deleteOperatorAccount = (
  params: DeleteOperatorAccountParams,
  options: RequestOptions = {}
): Promise<DeleteOperatorAccountResult> =>
  request(
    'DELETE',
    `/api/v2/quartz/operator/accounts/${params.accountId}`,
    {
      ...params,
      headers: {
        ...params.headers,
        'Content-Type': 'application/json; charset=utf-8',
      },
    },
    options
  ) as Promise<DeleteOperatorAccountResult>

export interface PatchOperatorAccountsConvertParams {
  accountId: string

  data: {
    /** the date the contract starts (YYYY-MM-DD) */
    contractStartDate: string
  }

  headers?: {
    'Zap-Trace-Span'?: string
  }
}

type PatchOperatorAccountsConvertResult =
  | PatchOperatorAccountsConvertOKResult
  | PatchOperatorAccountsConvertUnauthorizedResult
  | PatchOperatorAccountsConvertUnprocessableEntityResult
  | PatchOperatorAccountsConvertDefaultResult

interface PatchOperatorAccountsConvertOKResult {
  status: 200
  headers: Headers
  data: OperatorAccount
}

interface PatchOperatorAccountsConvertUnauthorizedResult {
  status: 401
  headers: Headers
  data: Error
}

interface PatchOperatorAccountsConvertUnprocessableEntityResult {
  status: 422
  headers: Headers
  data: Error
}

interface PatchOperatorAccountsConvertDefaultResult {
  status: 500
  headers: Headers
  data: Error
}

export const patchOperatorAccountsConvert = (
  params: PatchOperatorAccountsConvertParams,
  options: RequestOptions = {}
): Promise<PatchOperatorAccountsConvertResult> =>
  request(
    'PATCH',
    `/api/v2/quartz/operator/accounts/${params.accountId}/convert`,
    {
      ...params,
      headers: {...params.headers, 'Content-Type': 'application/json'},
    },
    options
  ) as Promise<PatchOperatorAccountsConvertResult>

export interface GetOperatorProvidersParams {}

type GetOperatorProvidersResult =
  | GetOperatorProvidersOKResult
  | GetOperatorProvidersUnauthorizedResult
  | GetOperatorProvidersDefaultResult

interface GetOperatorProvidersOKResult {
  status: 200
  headers: Headers
  data: OperatorProvidersResponse
}

interface GetOperatorProvidersUnauthorizedResult {
  status: 401
  headers: Headers
  data: Error
}

interface GetOperatorProvidersDefaultResult {
  status: 500
  headers: Headers
  data: Error
}

export const getOperatorProviders = (
  params: GetOperatorProvidersParams,
  options: RequestOptions = {}
): Promise<GetOperatorProvidersResult> =>
  request(
    'GET',
    '/api/v2/quartz/operator/providers',
    params,
    options
  ) as Promise<GetOperatorProvidersResult>

export interface GetOperatorOrgsParams {
  query?: {
    query?: string
    accountTypes?: any
    providers?: any
    regions?: any
  }

  headers?: {
    'Zap-Trace-Span'?: string
  }
}

type GetOperatorOrgsResult =
  | GetOperatorOrgsOKResult
  | GetOperatorOrgsUnauthorizedResult
  | GetOperatorOrgsDefaultResult

interface GetOperatorOrgsOKResult {
  status: 200
  headers: Headers
  data: OperatorOrganizations
}

interface GetOperatorOrgsUnauthorizedResult {
  status: 401
  headers: Headers
  data: Error
}

interface GetOperatorOrgsDefaultResult {
  status: 500
  headers: Headers
  data: Error
}

export const getOperatorOrgs = (
  params: GetOperatorOrgsParams,
  options: RequestOptions = {}
): Promise<GetOperatorOrgsResult> =>
  request(
    'GET',
    '/api/v2/quartz/operator/orgs',
    params,
    options
  ) as Promise<GetOperatorOrgsResult>

export interface GetOperatorOrgParams {
  orgId: string

  headers?: {
    'Zap-Trace-Span'?: string
  }
}

type GetOperatorOrgResult =
  | GetOperatorOrgOKResult
  | GetOperatorOrgUnauthorizedResult
  | GetOperatorOrgNotFoundResult
  | GetOperatorOrgDefaultResult

interface GetOperatorOrgOKResult {
  status: 200
  headers: Headers
  data: OperatorOrganization
}

interface GetOperatorOrgUnauthorizedResult {
  status: 401
  headers: Headers
  data: Error
}

interface GetOperatorOrgNotFoundResult {
  status: 404
  headers: Headers
  data: Error
}

interface GetOperatorOrgDefaultResult {
  status: 500
  headers: Headers
  data: Error
}

export const getOperatorOrg = (
  params: GetOperatorOrgParams,
  options: RequestOptions = {}
): Promise<GetOperatorOrgResult> =>
  request(
    'GET',
    `/api/v2/quartz/operator/orgs/${params.orgId}`,
    params,
    options
  ) as Promise<GetOperatorOrgResult>

export interface GetOperatorOrgsLimitsParams {
  orgId: string

  headers?: {
    'Zap-Trace-Span'?: string
  }
}

type GetOperatorOrgsLimitsResult =
  | GetOperatorOrgsLimitsOKResult
  | GetOperatorOrgsLimitsUnauthorizedResult
  | GetOperatorOrgsLimitsNotFoundResult
  | GetOperatorOrgsLimitsDefaultResult

interface GetOperatorOrgsLimitsOKResult {
  status: 200
  headers: Headers
  data: OperatorOrgLimits
}

interface GetOperatorOrgsLimitsUnauthorizedResult {
  status: 401
  headers: Headers
  data: Error
}

interface GetOperatorOrgsLimitsNotFoundResult {
  status: 404
  headers: Headers
  data: Error
}

interface GetOperatorOrgsLimitsDefaultResult {
  status: 500
  headers: Headers
  data: Error
}

export const getOperatorOrgsLimits = (
  params: GetOperatorOrgsLimitsParams,
  options: RequestOptions = {}
): Promise<GetOperatorOrgsLimitsResult> =>
  request(
    'GET',
    `/api/v2/quartz/operator/orgs/${params.orgId}/limits`,
    params,
    options
  ) as Promise<GetOperatorOrgsLimitsResult>

export interface PutOperatorOrgsLimitsParams {
  orgId: string

  data: OperatorOrgLimits

  headers?: {
    'Zap-Trace-Span'?: string
  }
}

type PutOperatorOrgsLimitsResult =
  | PutOperatorOrgsLimitsOKResult
  | PutOperatorOrgsLimitsBadRequestResult
  | PutOperatorOrgsLimitsUnauthorizedResult
  | PutOperatorOrgsLimitsNotFoundResult
  | PutOperatorOrgsLimitsDefaultResult

interface PutOperatorOrgsLimitsOKResult {
  status: 200
  headers: Headers
  data: OperatorOrgLimits
}

interface PutOperatorOrgsLimitsBadRequestResult {
  status: 400
  headers: Headers
  data: Error
}

interface PutOperatorOrgsLimitsUnauthorizedResult {
  status: 401
  headers: Headers
  data: Error
}

interface PutOperatorOrgsLimitsNotFoundResult {
  status: 404
  headers: Headers
  data: Error
}

interface PutOperatorOrgsLimitsDefaultResult {
  status: 500
  headers: Headers
  data: Error
}

export const putOperatorOrgsLimits = (
  params: PutOperatorOrgsLimitsParams,
  options: RequestOptions = {}
): Promise<PutOperatorOrgsLimitsResult> =>
  request(
    'PUT',
    `/api/v2/quartz/operator/orgs/${params.orgId}/limits`,
    {
      ...params,
      headers: {...params.headers, 'Content-Type': 'application/json'},
    },
    options
  ) as Promise<PutOperatorOrgsLimitsResult>

export interface PatchUserParams {
  userId: string

  data: UserPatchRequest
}

type PatchUserResult =
  | PatchUserOKResult
  | PatchUserUnauthorizedResult
  | PatchUserUnprocessableEntityResult
  | PatchUserDefaultResult

interface PatchUserOKResult {
  status: 200
  headers: Headers
  data: User
}

interface PatchUserUnauthorizedResult {
  status: 401
  headers: Headers
  data: Error
}

interface PatchUserUnprocessableEntityResult {
  status: 422
  headers: Headers
  data: Error
}

interface PatchUserDefaultResult {
  status: 500
  headers: Headers
  data: Error
}

export const patchUser = (
  params: PatchUserParams,
  options: RequestOptions = {}
): Promise<PatchUserResult> =>
  request(
    'PATCH',
    `/api/v2/quartz/users/${params.userId}`,
    {...params, headers: {'Content-Type': 'application/json'}},
    options
  ) as Promise<PatchUserResult>

export interface GetAuthConnectionParams {
  query: {
    email: string
  }

  headers?: {
    'Zap-Trace-Span'?: string
  }
}

type GetAuthConnectionResult =
  | GetAuthConnectionOKResult
  | GetAuthConnectionNoContentResult
  | GetAuthConnectionDefaultResult

interface GetAuthConnectionOKResult {
  status: 200
  headers: Headers
  data: string
}

interface GetAuthConnectionNoContentResult {
  status: 204
  headers: Headers
  data: any
}

interface GetAuthConnectionDefaultResult {
  status: 500
  headers: Headers
  data: Error
}

export const getAuthConnection = (
  params: GetAuthConnectionParams,
  options: RequestOptions = {}
): Promise<GetAuthConnectionResult> =>
  request(
    'GET',
    '/api/v2/quartz/auth/connection',
    params,
    options
  ) as Promise<GetAuthConnectionResult>
