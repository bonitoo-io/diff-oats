// This file is generated by [oats][0] and should not be edited by hand.
//
// [0]: https://github.com/influxdata/oats

export interface OAuthClientConfig {
  clientID: string
  domain: string
  redirectURL: string
  state: string
}

export interface Error {
  /** code is the machine-readable error code. */
  readonly code:
    | 'internal error'
    | 'not found'
    | 'conflict'
    | 'invalid'
    | 'unprocessable entity'
    | 'empty value'
    | 'unavailable'
    | 'forbidden'
    | 'too many requests'
    | 'unauthorized'
    | 'method not allowed'
    | 'request too large'
    | 'unsupported media type'
  /** Human-readable message. */
  readonly message?: string
  /** Describes the logical code operation when the error occurred. Useful for debugging. */
  readonly op?: string
  /** Stack of errors that occurred during processing of the request. Useful for debugging. */
  readonly err?: string
}

export interface LimitEvents {
  links?: Links
  events?: LimitEvent[]
}

/**
 * URI pointers for additional paged results.

*/
export interface Links {
  next?: Link
  self: Link
  prev?: Link
}

/**
 * URI of resource.
 */
export type Link = string

export interface LimitEvent {
  orgID?: string
  type?:
    | 'limited_quota'
    | 'limited_write'
    | 'limited_query'
    | 'limited_cardinality'
  readonly timestamp?: string
}

/**
 * These are org limits similar to those configured in/by quartz.
 */
export interface Limit {
  orgID?: string
  rate: {
    /** Query Time in nanoseconds */
    queryTime: number
    /** Query limit in kb/sec. 0 is unlimited. */
    readKBs: number
    /** Allowed concurrent queries. 0 is unlimited. */
    concurrentReadRequests: number
    /** Write limit in kb/sec. 0 is unlimited. */
    writeKBs: number
    /** Allowed concurrent writes. 0 is unlimited. */
    concurrentWriteRequests: number
    /** Allowed organization total cardinality. 0 is unlimited. */
    cardinality: number
    /** Allowed organization concurrent outstanding delete requests. */
    concurrentDeleteRequests?: number
    /** Allowed organization delete request rate. */
    deleteRequestsPerSecond?: number
  }
  bucket: {
    maxBuckets: number
    /** Max bucket retention duration in nanoseconds. 0 is unlimited. */
    maxRetentionDuration: number
  }
  task: {
    maxTasks: number
  }
  dashboard: {
    maxDashboards: number
  }
  check: {
    maxChecks: number
  }
  notificationRule: {
    maxNotifications: number
    /** comma separated list of notification rules */
    blockedNotificationRules?: string
  }
  notificationEndpoint: {
    /** comma separated list of notification endpoints */
    blockedNotificationEndpoints?: string
  }
  features?: {
    /** allow delete predicate endpoint */
    allowDelete?: boolean
  }
}

/**
 * Non 2XX error response from server.
 */
export type ServerError = any

export interface LimitStatuses {
  read: LimitStatus
  write: LimitStatus
  cardinality: LimitStatus
}

export interface LimitStatus {
  status: 'ok' | 'exceeded'
}

export interface OrgSettings {
  /** The ID of the organization. */
  orgID?: string
  settings?: OrgSetting[]
}

export interface OrgSetting {
  key?: string
  value?: string
}

export interface OnboardingRequest {
  username: string
  password?: string
  org: string
  bucket: string
  retentionPeriodHrs?: number
  retentionPeriodSeconds?: number
  limit?: Limit
}

export interface OnboardingResponse {
  user?: {
    /** The ID of the user.
     */
    readonly id?: string
    /** The name of the user.
     */
    name: string
    /** The status of a user. An inactive user won't have access to resources.
     */
    status?: 'active' | 'inactive'
    readonly links?: {
      self?: string
    }
  }
  org?: {
    readonly links?: {
      self?: Link
      members?: Link
      owners?: Link
      labels?: Link
      secrets?: Link
      buckets?: Link
      tasks?: Link
      dashboards?: Link
    }
    readonly id?: string
    name: string
    description?: string
    readonly createdAt?: string
    readonly updatedAt?: string
    /** If inactive the organization is inactive. */
    status?: 'active' | 'inactive'
  }
  bucket?: {
    readonly links?: {
      /** URL to retrieve labels for this bucket. */
      labels?: Link
      /** URL to retrieve members that can read this bucket. */
      members?: Link
      /** URL to retrieve parent organization for this bucket. */
      org?: Link
      /** URL to retrieve owners that can read and write to this bucket. */
      owners?: Link
      /** URL for this bucket. */
      self?: Link
      /** URL to write line protocol to this bucket. */
      write?: Link
    }
    readonly id?: string
    readonly type?: 'user' | 'system'
    name: string
    description?: string
    orgID?: string
    rp?: string
    schemaType?: 'implicit' | 'explicit'
    readonly createdAt?: string
    readonly updatedAt?: string
    /** Retention rules to expire or retain data.
#### InfluxDB Cloud

- `retentionRules` is required.

#### InfluxDB OSS

- `retentionRules` isn't required.
 */
    retentionRules: Array<{
      type?: 'expire'
      /** The duration in seconds for how long data will be kept in the database.
The default duration is 2592000 (30 days).
0 represents infinite retention.
 */
      everySeconds: number
      /** The shard group duration.
The duration or interval (in seconds) that each shard group covers.

#### InfluxDB Cloud

- Does not use `shardGroupDurationsSeconds`.

#### InfluxDB OSS

- Default value depends on the
[bucket retention period]({{% INFLUXDB_DOCS_URL %}}/v2.3/reference/internals/shards/#shard-group-duration).
 */
      shardGroupDurationSeconds?: number
    }>
    labels?: Array<{
      readonly id?: string
      readonly orgID?: string
      name?: string
      /** Key-value pairs associated with this label.
To remove a property, send an update with an empty value (`""`) for the key.
 */
      properties?: any
    }>
  }
  auth?: {
    /** Status of the token. If `inactive`, requests using the token will be rejected. */
    status?: 'active' | 'inactive'
    /** A description of the token. */
    description?: string
  } & {
    readonly createdAt?: string
    readonly updatedAt?: string
    /** The ID of the organization that the authorization is scoped to. */
    orgID?: string
    /** List of permissions for an auth.  An auth must have at least one Permission. */
    permissions?: Array<{
      action: 'read' | 'write'
      resource: {
        type:
          | 'authorizations'
          | 'buckets'
          | 'dashboards'
          | 'orgs'
          | 'tasks'
          | 'telegrafs'
          | 'users'
          | 'variables'
          | 'secrets'
          | 'labels'
          | 'views'
          | 'documents'
          | 'notificationRules'
          | 'notificationEndpoints'
          | 'checks'
          | 'dbrp'
          | 'flows'
          | 'annotations'
          | 'functions'
        /** If ID is set that is a permission for a specific resource. if it is not set it is a permission for all resources of that resource type. */
        id?: string
        /** Optional name of the resource if the resource has a name field. */
        name?: string
        /** If orgID is set that is a permission for all resources owned my that org. if it is not set it is a permission for all resources of that resource type. */
        orgID?: string
        /** Optional name of the organization of the organization with orgID. */
        org?: string
      }
    }>
    readonly id?: string
    /** Passed via the Authorization Header and Token Authentication type. */
    readonly token?: string
    /** The ID of the user that created and owns the token. */
    readonly userID?: string
    /** The name of the user that created and owns the token. */
    readonly user?: string
    /** The name of the organization that the token is scoped to. */
    readonly org?: string
    readonly links?: {
      readonly self?: Link
      readonly user?: Link
    }
  }
}

export interface ProvisionRequest {
  user: Identity
  org: Identity
  config: {
    /** name of non system bucket */
    bucket?: string
    /** retention period of non system bucket */
    retentionPeriodSeconds?: number
    limit?: Limit
  }
  /** if true will return the auth token in the response */
  returnToken?: boolean
}

export interface Identity {
  id?: string
  name?: string
}

export interface ProvisionResponse {
  user?: Identity
  org?: IdentityWithLinks
  /** the token for the created user */
  token?: string
}

export interface IdentityWithLinks {
  id?: string
  name?: string
  links?: Links
}

export interface ProvisionDeleteRequest {
  /** organization id to delete */
  orgID: string
}

export interface ProvisionUserRequest {
  user: Identity
  /** organization id to add user to */
  orgID: string
  /** Role of the User */
  role: 'owner' | 'member'
}

export interface ProvisionUserResponse {
  user?: Identity
  org?: Identity
}

export interface ProvisionUserDeleteRequest {
  /** user id to delete */
  userID: string
  /** organization id the user should be deleted from */
  orgID: string
  /** user id of the owner that user-owned resources should be transferred to. should be omitted if not transferring resources. */
  newOwnerID?: string
  /** delete or transfer tokens */
  tokenOption?: 'transfer' | 'delete'
  /** delete or transfer tasks */
  taskOption?: 'transfer' | 'delete'
}

export interface ProvisionSetupRequest {
  user: Identity
  org: Identity
}

export interface ProvisionSuspendRequest {
  /** organization id to suspend or unsuspend */
  orgID: string
}

interface RequestOptions {
  signal?: AbortSignal
}

export type RequestHandler = (
  url: string,
  query: string,
  init: RequestInit
) => {url: string; query: string; init: RequestInit}
export type ResponseHandler = (
  status: number,
  headers: Headers,
  data: any
) => {status: number; headers: Headers; data: any}

const RequestContext = function (
  requestHandler: RequestHandler,
  responseHandler: ResponseHandler
) {
  this.requestHandler = requestHandler
  this.responseHandler = responseHandler
}

RequestContext.prototype.request = async function (
  method: string,
  url: string,
  params: any = {},
  options: RequestOptions = {}
): Promise<any> {
  const requestHeaders = new Headers(params.headers)
  const contentType = requestHeaders.get('Content-Type') || ''

  if (params.auth) {
    const credentials = btoa(`${params.auth.username}:${params.auth.password}`)

    requestHeaders.append('Authorization', `Basic ${credentials}`)
  }

  const body =
    params.data && contentType.includes('json')
      ? JSON.stringify(params.data)
      : params.data

  const query = params.query ? `?${new URLSearchParams(params.query)}` : ''

  const {
    url: middlewareUrl,
    query: middlewareQuery,
    init,
  } = this.requestHandler(url, query, {
    method,
    body,
    credentials: 'same-origin',
    signal: options.signal,
    headers: requestHeaders,
  })

  const response = await fetch(`${middlewareUrl}${middlewareQuery}`, init)

  const {status, headers} = response
  const responseContentType = headers.get('Content-Type') || ''

  let data

  if (responseContentType.includes('json')) {
    data = await response.json()
  } else if (responseContentType.includes('octet-stream')) {
    data = await response.blob()
  } else {
    data = await response.text()
  }

  return this.responseHandler(status, headers, data)
}

RequestContext.prototype.setRequestHandler = function (
  requestHandler: RequestHandler
) {
  this.requestHandler = requestHandler
}

RequestContext.prototype.setResponseHandler = function (
  responseHandler: ResponseHandler
) {
  this.responseHandler = responseHandler
}

const rc = new RequestContext(
  (url, query, init) => {
    return {url, query, init}
  },
  (status, headers, data) => {
    return {status, headers, data}
  }
)
const request = rc.request.bind(rc)
const setRequestHandler = rc.setRequestHandler.bind(rc)
const setResponseHandler = rc.setResponseHandler.bind(rc)

export {request, setRequestHandler, setResponseHandler}

export interface GetOauthClientConfigParams {
  query?: {
    redirectTo?: string
  }
}

type GetOauthClientConfigResult =
  | GetOauthClientConfigOKResult
  | GetOauthClientConfigDefaultResult

interface GetOauthClientConfigOKResult {
  status: 200
  headers: Headers
  data: OAuthClientConfig
}

interface GetOauthClientConfigDefaultResult {
  status: 500
  headers: Headers
  data: Error
}

export const getOauthClientConfig = (
  params: GetOauthClientConfigParams,
  options: RequestOptions = {}
): Promise<GetOauthClientConfigResult> =>
  request(
    'GET',
    '/api/v2private/oauth/clientConfig',
    params,
    options
  ) as Promise<GetOauthClientConfigResult>

export interface GetFlagsParams {}

type GetFlagsResult = GetFlagsOKResult | GetFlagsDefaultResult

interface GetFlagsOKResult {
  status: 200
  headers: Headers
  data: any
}

interface GetFlagsDefaultResult {
  status: 500
  headers: Headers
  data: Error
}

export const getFlags = (
  params: GetFlagsParams,
  options: RequestOptions = {}
): Promise<GetFlagsResult> =>
  request(
    'GET',
    '/api/v2private/flags',
    params,
    options
  ) as Promise<GetFlagsResult>

export interface GetLimiteventsParams {
  query: {
    orgID: string
    start?: string
    stop?: string
    limit?: number
    offset?: number
  }
}

type GetLimiteventsResult = GetLimiteventsOKResult | GetLimiteventsDefaultResult

interface GetLimiteventsOKResult {
  status: 200
  headers: Headers
  data: LimitEvents
}

interface GetLimiteventsDefaultResult {
  status: 500
  headers: Headers
  data: Error
}

export const getLimitevents = (
  params: GetLimiteventsParams,
  options: RequestOptions = {}
): Promise<GetLimiteventsResult> =>
  request(
    'GET',
    '/api/v2private/limitevents',
    params,
    options
  ) as Promise<GetLimiteventsResult>

export interface GetOrgsLimitsParams {
  orgID: string
}

type GetOrgsLimitsResult = GetOrgsLimitsOKResult | GetOrgsLimitsDefaultResult

interface GetOrgsLimitsOKResult {
  status: 200
  headers: Headers
  data: Limit
}

interface GetOrgsLimitsDefaultResult {
  status: 500
  headers: Headers
  data: Error
}

export const getOrgsLimits = (
  params: GetOrgsLimitsParams,
  options: RequestOptions = {}
): Promise<GetOrgsLimitsResult> =>
  request(
    'GET',
    `/api/v2private/orgs/${params.orgID}/limits`,
    params,
    options
  ) as Promise<GetOrgsLimitsResult>

export interface PutOrgsLimitsParams {
  orgID: string

  data: Limit
}

type PutOrgsLimitsResult = PutOrgsLimitsOKResult | PutOrgsLimitsDefaultResult

interface PutOrgsLimitsOKResult {
  status: 200
  headers: Headers
  data: Limit
}

interface PutOrgsLimitsDefaultResult {
  status: 500
  headers: Headers
  data: Error
}

export const putOrgsLimits = (
  params: PutOrgsLimitsParams,
  options: RequestOptions = {}
): Promise<PutOrgsLimitsResult> =>
  request(
    'PUT',
    `/api/v2private/orgs/${params.orgID}/limits`,
    {...params, headers: {'Content-Type': 'application/json'}},
    options
  ) as Promise<PutOrgsLimitsResult>

export interface PatchOrgsLimitsParams {
  orgID: string

  data: {
    orgID?: string
    rate?: {
      /** Query Time in nanoseconds */
      queryTime?: number
      /** Query limit in kb/sec. 0 is unlimited. */
      readKBs?: number
      /** Allowed concurrent queries. 0 is unlimited. */
      concurrentReadRequests?: number
      /** Write limit in kb/sec. 0 is unlimited. */
      writeKBs?: number
      /** Allowed concurrent writes. 0 is unlimited. */
      concurrentWriteRequests?: number
      /** Allowed organization total cardinality. 0 is unlimited. */
      cardinality?: number
      /** Allowed organization concurrent outstanding delete requests. */
      concurrentDeleteRequests?: number
      /** Allowed organization delete request rate. */
      deleteRequestsPerSecond?: number
    }
    bucket?: {
      maxBuckets?: number
      /** Max bucket retention duration in nanoseconds. 0 is unlimited. */
      maxRetentionDuration?: number
    }
    task?: {
      maxTasks: number
    }
    dashboard?: {
      maxDashboards: number
    }
    check?: {
      maxChecks: number
    }
    notificationRule?: {
      maxNotifications?: number
      /** comma separated list of notification rules */
      blockedNotificationRules?: string
    }
    notificationEndpoint?: {
      /** comma separated list of notification endpoints */
      blockedNotificationEndpoints?: string
    }
  }
}

type PatchOrgsLimitsResult =
  | PatchOrgsLimitsOKResult
  | PatchOrgsLimitsUnprocessableEntityResult
  | PatchOrgsLimitsDefaultResult

interface PatchOrgsLimitsOKResult {
  status: 200
  headers: Headers
  data: Limit
}

interface PatchOrgsLimitsUnprocessableEntityResult {
  status: 422
  headers: Headers
  data: ServerError
}

interface PatchOrgsLimitsDefaultResult {
  status: 500
  headers: Headers
  data: Error
}

export const patchOrgsLimits = (
  params: PatchOrgsLimitsParams,
  options: RequestOptions = {}
): Promise<PatchOrgsLimitsResult> =>
  request(
    'PATCH',
    `/api/v2private/orgs/${params.orgID}/limits`,
    {...params, headers: {'Content-Type': 'application/json'}},
    options
  ) as Promise<PatchOrgsLimitsResult>

export interface GetOrgsLimitsStatusParams {
  orgID: string
}

type GetOrgsLimitsStatusResult =
  | GetOrgsLimitsStatusOKResult
  | GetOrgsLimitsStatusDefaultResult

interface GetOrgsLimitsStatusOKResult {
  status: 200
  headers: Headers
  data: LimitStatuses
}

interface GetOrgsLimitsStatusDefaultResult {
  status: 500
  headers: Headers
  data: Error
}

export const getOrgsLimitsStatus = (
  params: GetOrgsLimitsStatusParams,
  options: RequestOptions = {}
): Promise<GetOrgsLimitsStatusResult> =>
  request(
    'GET',
    `/api/v2private/orgs/${params.orgID}/limits/status`,
    params,
    options
  ) as Promise<GetOrgsLimitsStatusResult>

export interface GetOrgsSettingsParams {
  orgID: string
}

type GetOrgsSettingsResult =
  | GetOrgsSettingsOKResult
  | GetOrgsSettingsDefaultResult

interface GetOrgsSettingsOKResult {
  status: 200
  headers: Headers
  data: OrgSettings
}

interface GetOrgsSettingsDefaultResult {
  status: 500
  headers: Headers
  data: Error
}

export const getOrgsSettings = (
  params: GetOrgsSettingsParams,
  options: RequestOptions = {}
): Promise<GetOrgsSettingsResult> =>
  request(
    'GET',
    `/api/v2private/orgs/${params.orgID}/settings`,
    params,
    options
  ) as Promise<GetOrgsSettingsResult>

export interface PutOrgsSettingsParams {
  orgID: string

  data: OrgSettings
}

type PutOrgsSettingsResult =
  | PutOrgsSettingsOKResult
  | PutOrgsSettingsDefaultResult

interface PutOrgsSettingsOKResult {
  status: 200
  headers: Headers
  data: OrgSettings
}

interface PutOrgsSettingsDefaultResult {
  status: 500
  headers: Headers
  data: Error
}

export const putOrgsSettings = (
  params: PutOrgsSettingsParams,
  options: RequestOptions = {}
): Promise<PutOrgsSettingsResult> =>
  request(
    'PUT',
    `/api/v2private/orgs/${params.orgID}/settings`,
    {...params, headers: {'Content-Type': 'application/json'}},
    options
  ) as Promise<PutOrgsSettingsResult>

export interface PostSetupUserParams {
  data: OnboardingRequest
}

type PostSetupUserResult =
  | PostSetupUserCreatedResult
  | PostSetupUserDefaultResult

interface PostSetupUserCreatedResult {
  status: 201
  headers: Headers
  data: OnboardingResponse
}

interface PostSetupUserDefaultResult {
  status: 500
  headers: Headers
  data: Error
}

export const postSetupUser = (
  params: PostSetupUserParams,
  options: RequestOptions = {}
): Promise<PostSetupUserResult> =>
  request(
    'POST',
    '/api/v2private/setup/user',
    {...params, headers: {'Content-Type': 'application/json'}},
    options
  ) as Promise<PostSetupUserResult>

export interface PutProvisionParams {
  data: ProvisionRequest
}

type PutProvisionResult =
  | PutProvisionCreatedResult
  | PutProvisionBadRequestResult
  | PutProvisionUnauthorizedResult
  | PutProvisionForbiddenResult
  | PutProvisionUnprocessableEntityResult
  | PutProvisionNotImplementedResult
  | PutProvisionDefaultResult

interface PutProvisionCreatedResult {
  status: 201
  headers: Headers
  data: ProvisionResponse
}

interface PutProvisionBadRequestResult {
  status: 400
  headers: Headers
  data: ServerError
}

interface PutProvisionUnauthorizedResult {
  status: 401
  headers: Headers
  data: ServerError
}

interface PutProvisionForbiddenResult {
  status: 403
  headers: Headers
  data: ServerError
}

interface PutProvisionUnprocessableEntityResult {
  status: 422
  headers: Headers
  data: ServerError
}

interface PutProvisionNotImplementedResult {
  status: 501
  headers: Headers
  data: ServerError
}

interface PutProvisionDefaultResult {
  status: 500
  headers: Headers
  data: Error
}

export const putProvision = (
  params: PutProvisionParams,
  options: RequestOptions = {}
): Promise<PutProvisionResult> =>
  request(
    'PUT',
    '/api/v2private/provision',
    {...params, headers: {'Content-Type': 'application/json'}},
    options
  ) as Promise<PutProvisionResult>

export interface PostProvisionDeleteParams {
  data: ProvisionDeleteRequest
}

type PostProvisionDeleteResult =
  | PostProvisionDeleteNoContentResult
  | PostProvisionDeleteBadRequestResult
  | PostProvisionDeleteUnauthorizedResult
  | PostProvisionDeleteUnprocessableEntityResult
  | PostProvisionDeleteDefaultResult

interface PostProvisionDeleteNoContentResult {
  status: 204
  headers: Headers
  data: any
}

interface PostProvisionDeleteBadRequestResult {
  status: 400
  headers: Headers
  data: Error
}

interface PostProvisionDeleteUnauthorizedResult {
  status: 401
  headers: Headers
  data: Error
}

interface PostProvisionDeleteUnprocessableEntityResult {
  status: 422
  headers: Headers
  data: Error
}

interface PostProvisionDeleteDefaultResult {
  status: 500
  headers: Headers
  data: Error
}

export const postProvisionDelete = (
  params: PostProvisionDeleteParams,
  options: RequestOptions = {}
): Promise<PostProvisionDeleteResult> =>
  request(
    'POST',
    '/api/v2private/provision/delete',
    {...params, headers: {'Content-Type': 'application/json'}},
    options
  ) as Promise<PostProvisionDeleteResult>

export interface PutProvisionUserParams {
  data: ProvisionUserRequest

  headers?: {
    'Zap-Trace-Span'?: string
  }
}

type PutProvisionUserResult =
  | PutProvisionUserCreatedResult
  | PutProvisionUserBadRequestResult
  | PutProvisionUserUnauthorizedResult
  | PutProvisionUserUnprocessableEntityResult
  | PutProvisionUserNotImplementedResult
  | PutProvisionUserDefaultResult

interface PutProvisionUserCreatedResult {
  status: 201
  headers: Headers
  data: ProvisionUserResponse
}

interface PutProvisionUserBadRequestResult {
  status: 400
  headers: Headers
  data: ServerError
}

interface PutProvisionUserUnauthorizedResult {
  status: 401
  headers: Headers
  data: ServerError
}

interface PutProvisionUserUnprocessableEntityResult {
  status: 422
  headers: Headers
  data: ServerError
}

interface PutProvisionUserNotImplementedResult {
  status: 501
  headers: Headers
  data: ServerError
}

interface PutProvisionUserDefaultResult {
  status: 500
  headers: Headers
  data: Error
}

export const putProvisionUser = (
  params: PutProvisionUserParams,
  options: RequestOptions = {}
): Promise<PutProvisionUserResult> =>
  request(
    'PUT',
    '/api/v2private/provision/user',
    {
      ...params,
      headers: {...params.headers, 'Content-Type': 'application/json'},
    },
    options
  ) as Promise<PutProvisionUserResult>

export interface PostProvisionUserDeleteParams {
  data: ProvisionUserDeleteRequest
}

type PostProvisionUserDeleteResult =
  | PostProvisionUserDeleteNoContentResult
  | PostProvisionUserDeleteBadRequestResult
  | PostProvisionUserDeleteUnauthorizedResult
  | PostProvisionUserDeleteUnprocessableEntityResult
  | PostProvisionUserDeleteDefaultResult

interface PostProvisionUserDeleteNoContentResult {
  status: 204
  headers: Headers
  data: any
}

interface PostProvisionUserDeleteBadRequestResult {
  status: 400
  headers: Headers
  data: Error
}

interface PostProvisionUserDeleteUnauthorizedResult {
  status: 401
  headers: Headers
  data: Error
}

interface PostProvisionUserDeleteUnprocessableEntityResult {
  status: 422
  headers: Headers
  data: Error
}

interface PostProvisionUserDeleteDefaultResult {
  status: 500
  headers: Headers
  data: Error
}

export const postProvisionUserDelete = (
  params: PostProvisionUserDeleteParams,
  options: RequestOptions = {}
): Promise<PostProvisionUserDeleteResult> =>
  request(
    'POST',
    '/api/v2private/provision/user/delete',
    {...params, headers: {'Content-Type': 'application/json'}},
    options
  ) as Promise<PostProvisionUserDeleteResult>

export interface PostProvisionSetupParams {
  data: ProvisionSetupRequest
}

type PostProvisionSetupResult =
  | PostProvisionSetupCreatedResult
  | PostProvisionSetupBadRequestResult
  | PostProvisionSetupUnprocessableEntityResult
  | PostProvisionSetupDefaultResult

interface PostProvisionSetupCreatedResult {
  status: 201
  headers: Headers
  data: {
    /** the token for the created user */
    token?: string
  }
}

interface PostProvisionSetupBadRequestResult {
  status: 400
  headers: Headers
  data: Error
}

interface PostProvisionSetupUnprocessableEntityResult {
  status: 422
  headers: Headers
  data: Error
}

interface PostProvisionSetupDefaultResult {
  status: 500
  headers: Headers
  data: Error
}

export const postProvisionSetup = (
  params: PostProvisionSetupParams,
  options: RequestOptions = {}
): Promise<PostProvisionSetupResult> =>
  request(
    'POST',
    '/api/v2private/provision/setup',
    {...params, headers: {'Content-Type': 'application/json'}},
    options
  ) as Promise<PostProvisionSetupResult>

export interface PostProvisionSuspendParams {
  data: ProvisionSuspendRequest
}

type PostProvisionSuspendResult =
  | PostProvisionSuspendNoContentResult
  | PostProvisionSuspendBadRequestResult
  | PostProvisionSuspendUnauthorizedResult
  | PostProvisionSuspendUnprocessableEntityResult
  | PostProvisionSuspendDefaultResult

interface PostProvisionSuspendNoContentResult {
  status: 204
  headers: Headers
  data: any
}

interface PostProvisionSuspendBadRequestResult {
  status: 400
  headers: Headers
  data: Error
}

interface PostProvisionSuspendUnauthorizedResult {
  status: 401
  headers: Headers
  data: Error
}

interface PostProvisionSuspendUnprocessableEntityResult {
  status: 422
  headers: Headers
  data: Error
}

interface PostProvisionSuspendDefaultResult {
  status: 500
  headers: Headers
  data: Error
}

export const postProvisionSuspend = (
  params: PostProvisionSuspendParams,
  options: RequestOptions = {}
): Promise<PostProvisionSuspendResult> =>
  request(
    'POST',
    '/api/v2private/provision/suspend',
    {...params, headers: {'Content-Type': 'application/json'}},
    options
  ) as Promise<PostProvisionSuspendResult>

export interface PostProvisionUnsuspendParams {
  data: ProvisionSuspendRequest
}

type PostProvisionUnsuspendResult =
  | PostProvisionUnsuspendNoContentResult
  | PostProvisionUnsuspendBadRequestResult
  | PostProvisionUnsuspendUnauthorizedResult
  | PostProvisionUnsuspendUnprocessableEntityResult
  | PostProvisionUnsuspendDefaultResult

interface PostProvisionUnsuspendNoContentResult {
  status: 204
  headers: Headers
  data: any
}

interface PostProvisionUnsuspendBadRequestResult {
  status: 400
  headers: Headers
  data: Error
}

interface PostProvisionUnsuspendUnauthorizedResult {
  status: 401
  headers: Headers
  data: Error
}

interface PostProvisionUnsuspendUnprocessableEntityResult {
  status: 422
  headers: Headers
  data: Error
}

interface PostProvisionUnsuspendDefaultResult {
  status: 500
  headers: Headers
  data: Error
}

export const postProvisionUnsuspend = (
  params: PostProvisionUnsuspendParams,
  options: RequestOptions = {}
): Promise<PostProvisionUnsuspendResult> =>
  request(
    'POST',
    '/api/v2private/provision/unsuspend',
    {...params, headers: {'Content-Type': 'application/json'}},
    options
  ) as Promise<PostProvisionUnsuspendResult>
